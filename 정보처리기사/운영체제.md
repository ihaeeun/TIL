## 운영체제 운용 기법
|        |                   |
| :----- | :---------------- |
|일괄 처리 시스템 (Batch File System)| 컴퓨터 시스템에서 사용된 형태로, 일정랼 또는 일정 기간동안 데이터를 모아서 한꺼번에 처리하는 방식
|다중 프로그래밍 시스템 (Multi-Programming System)| 하나의 CPU와 주기억장치를 이용해 여러 개의 프로그램을 동시에 처리하는 방식
|시분할 시스템 (Time Sharing System)| 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해 줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 주는 것. Round Robin 방식이라고도 함
|다중 처리 시스템 (Multi-Processing System)| 여러 개의 CPU와 하나의 주기억장치를 이용해 여러 개의 프로그램을 동시에 처리하는 방식
|실시간 처리 시스템 (Real Time Processing System)| 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식
|분산 처리 시스템 (Distributed Processing System)| 여러 개의 컴퓨터(프로세서)를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식

<br>

## 스케줄링
### 스케줄링 기법
#### 비선점(Non-preemptive) 스케줄링
* 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
* 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다.
* 모든 프로세스에 대한 요구를 공정하게 처리할 수 있다.
* 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합하다.
* 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있다.
* **종류** : FCFS, SJF, 우선수위, HRN, 기한부 등
#### 선점(Preemptive) 스케줄링
* 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
* 우선 순위가 높은 프로세스를 빠르게 처리할 수 있음
* 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용됨
* 많은 오버헤드를 초래함
* 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요하다.
* **종류** : RR, SRT, 선점 우선 순위, 다단계 큐, 다단계 피드백 큐 등
#
### SSTF
현재 헤드 위치에서 가장 가까운 거리에 있는 요청을 먼저 서비스 하는 기법
#
### HRN
**우선순위 공식** : (대기 시간 + 서비스 시간) / (서비스 시간)  
결과가 클수록 우선순위가 높음  
#
### Round-Robin(RR)
* 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당 받음.  
* 시분할 시스템을 위해 고안된 방식으로 FCFS 알고리즘을 선점 형태로 변형한 기법
* 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당 받지만, 각 프로세스는 시간 할당량 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치된다.
* 할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생된다.
* 할당되는 시간의 크기가 작으면 작은 프로세스들에게 유리하다.
#
### FIFO
준비상태 큐에 도착한 순서에 따라 CPU를 할당하는 기법
#
### C-SCAN
현재 헤드의 위치를 기준으로 항상 **바깥쪽에서 안쪽**으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 서비스하는 기법

<br>

## PCB에 저장되어 있는 정보
* 프로세스의 현재 상태
* 포인터
* 프로세스 고유 식별자
* 스케줄링 및 프로세스의 우선순위
* CPU 레지스터 정보
* 주기억장치 관리 정보
* 입출력 상태 정보
* 계정 정보

<br>

## UNIX 파일 시스템의 구조
|       |       |
|:------|:------|
|부트 블록|부팅 시 필요한 코드 저장
|슈퍼 블록|전체 파일 시스템에 대한 정보 저장
|I-node 블록|각 파일이나 디렉터리에 대한 모든 정보 저장 <br> (파일 소유자의 UID 및 GID, 파일 크기, 파일 타입, 생성 시기, 최종 변경 시기, 최근 사용시기, 파일의 보호권한, 파일 링크 수, 데이터가 저장된 블록의 시작 주소) <br> / * 포함되지 않는 것 : 파일의 사용된 횟수, 파일이 최초로 수정된 시간, 파일 경로명 *.
|데이터 블록|디렉터리 별로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장

<br>

## Shell과 Kernel
### 쉘
* 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
* 시스템과 사용자 간의 인터페이스 담당
* 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체처리 가능
* 공용 쉘이나 사용자 자신이 만든 쉘 사용 가능
#
### 커널
* UNIX의 가장 핵심적인 부분
* 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행됨
* 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할
* 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스 간 통신, 데이터 전송 및 변환 등 여러 기능

<br>

## 교착상태
### 발생 조건
* **상호배제**   
: 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
* **점유와 대기**  
: 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
* **비선점**
: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함
* **환형 대기**
: 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함
#
### 해결방법
|       |       |
|:------|:------|
|예방 기법| 교착 상태가 발생하지 않도록 사전에 시스템을 제어하는 방법 <br> 교착 상태의 발생 조건 중에 어느 하나를 제거함으로써 수행됨 <br> 자원의 낭비가 가장 심한 기법
|회피 기법| 교착 상태가 발생할 가능성을 배제하지 않고 교착 상태가 발생하면 적절히 피해나가는 방법 <br> **은행원 알고리즘**
|발견 기법| 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것
|회복 기법| 교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것

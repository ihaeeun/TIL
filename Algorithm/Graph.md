# 그래프
## 개념
- 객체들과 객체들 사이의 연결 관계 표현
- 정점(Vertex)들의 집합과 정점을 연결하는 간선(Edge)들의 집합으로 구성된 자료구조
    - G = (V, E), V: 정점들의 집합, E: 간선들의 집합
    - |V|: 정점의 개수, |E|: 그래프에 포함된 간선의 개수
    - |V|개의 정점을 가지는 그래프는 최대 |V|*(|V|-1)/2개의 간선 가능
- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기 용이

- 종류
    - 무향 그래프(Undirected Graph) : 서로 대칭적인 관계를 연결해서 나타낸 그래프
    - 유향 그래프(Directed Graph) : 간선을 화살표로 표현하고 방향성의 개념 포함
    - 가중치 그래프(Weighed Graph) : 이동하는데 드는 비용을 간선에 부여한 그래프

- 인접(Adjacency)
    - 두 개의 정점에 간선이 존재(연결됨)할 경우 서로 인접해 있다고 함
    - 방향성을 가지는 경우 (2<-1) 2번 정점은 1번 정점의 인접 정점이지만 1번 정점은 2번 정점의 인접 정점이 아님 

- 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

- 경로 : 간선들을 순서대로 나열한 것
    - 간선들 (0,2), (2,4), (4,6)
    - 정점들 0 - 2 - 4 - 6
- 단순 경로 : 경로 중 한 정점을 최대한 한 번만 지나는 경로
- 사이클 : 시작한 정점에서 끝나는 경로
- 사이클 없는 유향 그래프(DAG, Directed Acyclic Graph)


## 그래프 표현
- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접행렬 : |V| * |V| 크기의 2차원 리스트를 이용해서 간선 정보 저장
    - 두 저점을 연결하는 간선의 유무를 행렬 형태로 표현
    - 정점의 개수 n이 커지면 인접 행렬에 필요한 메모리 크기는 n^2에 비례하여 커짐
    - 어떤 정점의 인접 정점을 찾을 때마다, 천 개의 슬롯을 조사해야 함
    - 그래프에 포함된 간선의 수가 많지 않을 경우 메모리 사용을 줄이기 위해 간선들의 정보를 나열해서 저장
    - 간선의 시작 정점과 끝 정점의 정보 저장
    - 간선 리스트에서 어떤 정점의 인접 정점은 일치하는 시작 정점을 찾으면 됨

- 인접 리스트 : 각 정점마다 인접 정점으로 나가는 간선의 정보 저장
    - 정점의 개수에 비해 상대적으로 간선의 수가 적을 경우 간선들을 리스트에 연속적으로 저장해서 사용
    - 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
    - 정점의 개수만큼 메모리 주소를 저장하는 리스트 존재
    - 정점의 번호에 대응하는 곳 : 연결리스트의 첫번째 노드에 대한 주소 저장
    - 각 정점의 연결리스트 : 인접 정점의 개수만큼 노드 연결


<br><br>

## 상호배타 집합들
- 서로 중복 포함된 원소가 없는 집합들로 교집합이 없음
- 집합에 속한 하나의 특정 원소를 통해 각 잡합들을 구분
    - 특정 원소 - 대표자
- 상호배타 집합을 표현하는 방법
    - 연결리스트
        - 같은 집합의 원소들을 하나의 연결 리스트로 관리
        - 연결리스트이 첫 번째 원소를 집합의 대표 원소로 선택
        - 각 원소는 집합의 대표 원소를 가리키는 링크를 가짐
    - 트리
        - 하나의 집합을 하나의 트리로 표현
        - BFS의 최단 경로 트리를 사용
        - 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 됨
        - 리스트를 사용함 : 각 원소의 부모에 대한 정보를 저장하는 형태
        - 자기 자신을 부모로 가리키게 되면 집합의 대표자가 됨
- 그래프 알고리즘에서는 정점들을 원소로하는 상호 배타 집합들 이용

### 상호배타 집합 연산
- Make-Set(x) : 원소 x만으로 구성된 집합을 생성하는 연산
- Find-Set(x) : 임의의 원소 x가 속한 집합을 알아내기 위해 사용하며, 집합의 대표자를 알기 위한 연산
- Union(x, y) : x 원소가 속한 집합과 y 원소가 속한 집합을 하나의 집합으로 합치는 연산
    - 두 집합을 합칠 때는 크기가 작은 집합을 큰 집합 뒤에 연결

### 연산의 효율을 높이는 방법
1. Rank를 이용한 Union
    - 각 노드는 자신을 루트로 하는 Subtree의 높이를 Rank라는 이름으로 저장
    - 두 집합을 합칠 때 Rank가 낮은 집합을 Rank가 높은 집합에 붙임
    - 트리의 높이가 같은 두 집합을 합치는 경우 랭크 값이 변경 됨
2. Path compression
    - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 Root를 가리키도록 부모 정보 변경

### 트리 표현
1. Make_Set(x)
```python
# p[x]: 노드 x의 부모 저장
# rank[x]: 루트 노드가 x인 트리의 랭크 값 저장
def Make_Set(x):
    p[x] = x    # 자기 자신
    rank[x] = 0
```

2. Find_Set(x)
```python
def Find_Set(x):
    if x != p[x]:               # x가 루트가 아닌 경우
        p[x] = Find_Set(p[x])   # Path Compression
    return p[x]
```

3. Union
```python
def Union(x, y):
    Link(Find_Set(x), Find_Set(y))

def Link(x, y):
    if rank[x] > rank[y]:
        p[y] = x
    else:
        p[x] = y
    if rank[x] == rank[y]:
        rank[y] += 1
```
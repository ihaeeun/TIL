# 백트래킹
- 해를 찾는 도중에 막히면(해가 아니면) 되돌아가서 다시 해를 찾아가는 기법
- 최적화 문제와 결정 문제 해결 가능
- 결정 문제 : 문제의 조건을 만족하는 해가 존재하는지 여부를 'yes', 'no'로 답하는 문제
- 초기 상태에서 목표 상태로 가는 경로를 탐색하는 기법
    - 여러 가지 옵션들이 존재하는 상황에서 한가지 선택
    - 선택이 이루어지면 새로운 선택지들의 집합 생성
    - 선택을 반복하면서 최종 상태에 도달
### 상태 공간 트리
    - 해를 찾기 위한 선택의 과정을 트리로 표현
    - 트리의 내부 노드는 최종 상태로 가는 중간 상태를 나타냄
    - 트리의 단말 노드는 하나의 후보해에 대한 최종 상태
    - 상태 공간 트리 탐색 = 모든 후보해들을 탐색하는 것
    - DFS가 백트래킹 알고리즘의 기본 형태
### DFS와 백트래킹의 차이
    - 백트래킹의 경우 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임
    - 가지치기로 불필요한 경로를 조기에 차단

### 백트래킹을 이용한 알고리즘의 진행 절차
1. 상태 공간 트리에 대한 깊이 우선 탐색 실시
2. 방문하는 노드가 유망한지 여부 점검
3. 만일 선택한 노드가 유망하지 않을 경우, 해당 노드의 부모 노드로 돌아가서 검색 계속 진행
```psuedo
def checknode(v):                       # 현재 방문하는 노드
    if promisint(v):                    # 현재 방문하는 노드의 유망성 점검 후 유망하지 않은 경우 재귀 호출하지 않고 종료
        if there is a solution at v:    # 단말 노드에 도착하면 찾으려는 해인지 검사
            write the solution          # 찾은 해 출력
        else:                           # 단말노드가 아니라면
            for u in each child of v:   # 모든 자식 노드를 방문하기 위해 재귀호출
                checknoe(u)
```

### 4-Queens 문제
1. 4*4 정사각형 안에 네 개의 퀸에 대한 위치를 하나씩 선택
2. 첫 번째 퀸을 1행 1열에 놓고, 2행에 두 번째 퀸 놓기
3. 2행 1열과 2행 2열에 퀸을 두면 1행 1열에 있는 첫 번째 퀸과 서로 위협하므로 놓을 수 없음
4. 2행 3열에 두 번째 퀸을 놓게 되면 첫 번째 퀸과 서로 위협하지 않음
5. 세 번째 퀸을 3행 어디에 놓더라도 서로 위협하게 됨
6. 네 번째 퀸의 위치와 무관하게 답이 될 수 없음
7. 이전에 선택했던 두 번째 퀸의 위치를 4열에 놓음
8. 세 번째 퀸은 2열에 둠
9. 네 번째 퀸은 둘 곳이 없음
10. 세 번째 퀸을 다른 곳으로 옮겨도 안됨
11. 두 번째 퀸의 위치를 변경해야 하지만 이미 4열이므로 변경 불가
12. 첫 번째 퀸의 위치를 2열로 변경

## 부분집합
### Power set
- 어떤 집합의 공집합과 자기 자신을 포함한 모든 부분집합
- 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n

### 부분집합의 상태 공간 트리 - 깊이 우선탐색으로 모든 부분집합 생성 알고리즘
```python
def subset(a, k, n):
    if k == n:                  # 단말 노드에 도달 
        process_solution(a, n)
    else:
        a[k] = 0
        subset(a, k+1, n)
        a[k] = 1
        subset(a, k+1, n)
```
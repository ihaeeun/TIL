# 1. 객체지향언어
- 재사용성
- 유지보수
- 중복된 코드의 제거

# 2. 클래스와 객체
## 2.1 클래스와 객체의 정의와 용도
### 클래스
- 객체를 정의해 놓은 것
- 객체 생성에 사용

## 2.2 객체와 인스턴스
- 클래스로부터 만들어진 객체를 **인스턴스**라고 함

## 2.3 객체의 구성요소 - 속성과 기능
- 객체가 가지고 있는 속성(**멤버변수**)과 기능(**메서드**)을 그 객체의 멤버라 한다.

## 2.4 인스턴스의 생성과 사용
```
    클래스명 변수명;            // 클래스의 객체를 참조하기 위한 참조변수 선언
    변수명 = new 클래스명();    // 클래스의 객체 생성 후, 객체의 주소를 참조변수에 저장
```
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 함
- 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 'Garbage Collector'에 의해 자동적으로 메모리에서 제거됨

## 2.5 객체 배열
- 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열

# 3. 변수와 메서드
## 3.1 선언위치에 따른 변수의 종류
- 멤버변수
    - 클래스변수 : static 멤버변수 (공유 변수)
    - 인스턴스변수 : static 붙지 않은 멤버변수
- 지역변수 : 멤버변수를 제외한 나머지 변수

| 변수의 종류 | 선언위치 | 생성시기 | 
|:---:|:---:|:---:|
| 클래스변수 | 클래스 영역 | 클래스가 메모리에 올라갔을 때|
| 인스턴스변수 | 클래스 영역 | 인스턴스가 생성되었을 때|
| 지역변수 | 클래스 영역 이외의 영역(메소드, 생성자, 초기화 블럭 내부) 변수 |선언문이 수행되었을 때

## 3.7 JVM의 메모리 구조
1. 메소드 영역
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 클래스 데이터를 이곳에 저장
    - 클래스변수도 이 영역에 함께 생성됨
2. 힙
    - 프로그램 실행 중 생성되는 인스턴스가 생성되는 공간
    - 인스턴스변수들이 생성되는 공간
3. 호출스택
    - 메소드 작업에 필요한 메모리 공간을 제공
    - 메소드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용됨
    - 메소드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워짐

## 3.8 기본형 매개변수와 참조형 매개변수
- 메소드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻음(read only)
- 참조형으로 선언하면 저장된 곳의 주소를 알 수 있기 때문에 값 변경도 가능(read & write)

# 4. overloading
## 4.1 오버로딩이란?
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것

## 4.2 오버로딩의 조건
- 메소드 이름이 같아야 함
- 매개변수의 개수 또는 타입이 달라야 함

## 4.5 가변인자와 오버로딩
- 선언 : `타입... 변수명`
- 가변인자를 매개변수 중에서 제일 마지막에 선언해야 함
- 가변 인자를 사용할 경우, 인자의 개수가 가변적일 수 있고, 배열도 인자가 될 수 있음
- 가변인자는 내부적으로 배열을 이용함
- 가변인자가 선언된 메소드를 호출할 때마다 배열이 새로 생성됨

# 5. 생성자
## 5.1 생성자란?
- 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'
- 오버로딩 가능

## 5.2 기본 생성자
- 기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때

## 5.4 생성자에서 다른 생성자 호출하기 - this(), this
### this()
- 생성자 간 호출이 가능한 조건
    - 생성자의 이름으로 클래스이름 대신 this 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능

``` java
class Car{
    String color;
    String gearType;
    int door;

    // Car(String color, String gearType, int door) 호출
    Car(){
        this("white", "auto", 4);
    }

    Car(String color){
        this(color, "auto", 4);
    }

    Car(String color, String gearType, int door){
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```
   
### this
- 참조변수로 인스턴스 자신을 가리킴
- 인스턴스의 주소가 저장되어 있음
- 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 'this'가 지역변수로 숨겨진 채로 존재

## 5.5 생성자를 이용한 인스턴스의 복사
- 하나의 클래스로부터 생성된 모든 인스턴스의 메서드와 클래스 변수는 서로 동일
```java
class Car{
    String color;
    String gearType;
    int door;

    Car(){
        this("white", "auto", 4);
    }

    // 인스턴스의 복사를 위한 생성자
    Car(Car c){
        color = c.color;
        gearType = c.gearType;
        door = c.door;

    Car(String color, String gearType, int door){
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```

# 6. 변수의 초기화
## 6.1 변수의 초기화
- 멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화 됨
- 지역변수는 사용하기 전에 반드시 초기화 해야 함

- 멤버변수의 초기화 방법
    - 명시적 초기화 : 변수를 선언과 동시에 초기화 하는 것
    - 생성자
    - 초기화 블럭
        - 클래스 초기화 블럭
            - 클래스변수의 복잡한 초기화에 사용
            - 클래스가 메모리에 처음 로딩될 때 한번만 수행
        - 인스턴스 초기화 블럭
            - 인스턴스 변수의 복잡한 초기화에 사용
            - 생성자와 같이 인스턴스를 생성할 때마다 수행 
            - 생성자보다 인스턴스 초기화 블럭이 먼저 수행됨

```java 
class BlockTest{
    // 클래스 초기화 블럭
    static{
        System.out.println("static { }");
    }
    // 인스턴스 초기화 블럭
    {
        System.out.println("static { }");
    }
    ...
}
```
## 6.4 멤버변수의 초기화 시기와 순서
- 클래스 변수의 초기화시점 : 클래스가 처음 로딩될 때 한 번
- 인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화
- 클래스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

- 프로그램 실행도중 클래스에 대한 정보가 요구될 때, 클래스는 메모리에 로딩됨 (클래스 멤버 사용시, 인스턴스 생성 시 등)
- 해당 클래스가 이미 메모리에 로딩되어 있다면 또다시 로딩하지 않고, 초기화도 수행되지 않음

# 7. 상속
## 7.1 상속의 정의와 장점
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- `extends`
- 조상클래스 - 부모 클래스, super 클래스, base 클래스
- 자손클래스 - 자식 클래스, sub 클래스, derived 클래스
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.

## 7.2 클래스간의 관계 - 포함관계
- 클래스 간의 포함관계 : 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것
```java
class Point{
    int x;
    int y;
}

class Circle{
    Point p = new Point();
    int r;
}
```

## 7.4 단일 상속
- 자바는 단일 상속만 지원

## 7.5 Object 클래스 - 모든 클래스의 조상
- Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스

# 8. 오버라이딩
## 8.1 오버라이딩이란?
- 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것

## 8.2 오버라이딩의 조건
- 선언부가 서로 일치해야 함
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없음
- 예외는 조상 클래스의 베서드보다 많이 선언할 수 없음
- 인스턴스메서드를 static 메서드 또는 그 반대로 변경할 수 없음

## 8.4 super
- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때 super를 붙여서 구별 가능
- 조상 클래스의 메서드를 자손 클래스에서 오버라이딩 한 경우 super 사용

## 8.5 super() - 조상 클래스의 생성자
- super() : 조상 클래스의 생성자를 호출하는데 사용
- 조상 클래스 생성자의 호출은 클래스의 상속돤계를 거슬러 올라가면서 계속 반복됨
- Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 this() 또는 super()를 호출해야 함
- 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫줄에 삽입함

# 9. 다형성
## 9.1 다형성이란?
- 여러가지 형태를 가질 수 있는 능력
- 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성 구현
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함
- 조상클래스 타입의 참조변수가 자손클래스의 인스턴스를 참조하고 있는 경우 인스턴스의 모든 멤버를 사용할 수는 없음
- 같은 타입의 인스턴스여도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐
- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 함

## 9.2 참조변수의 형변환
- 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로 형변환 가능
- Up-casting : 자손타입 -> 조상타입, 형변환 생략 가능
- Down-casting : 조상타입 -> 자손타입, 형변환 생략 불가
- 형변환을 수행하기 전에 instanceof 연산자를 사용해 참조변수가 참조하고 있는 실제 인스턴스 타입을 확인하는 것이 안전
- 형변환은 참조변수의 타입을 변환할 뿐 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 영향을 주지 않음

## 9.4 참조변수와 인스턴스의 연결
- 메서드의 경우 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출됨
- 멤버변수의 경우 참조변수의 타입에 따라 달라짐

## 9.6. 여러 종류의 객체를 배열로 다루기
### Vector 클래스
- 내부적으로 Object 타입의 배열을 가지고 있어서, 이 배열에 객체를 추가하거나 제거할 수 있게 작성되어 있음
- 배열의 크기를 알아서 관리해줌
- 동적으로 크기가 관리되는 객체배열

# 10. 추상클래스
## 10.1 추상클래스란?
- 미완성 설계도
- `abstract` 
- 추상메소드를 포함하고 있음
- 추상메서드를 포함하고 있지 않은 클래스도 추상 클래스로 지정할 수 있음
    - 추상메서드가 없는 완성된 클래스라 해도 추상클래스로 지정되면 클래스의 인스턴스 생성 불가

## 10.2 추상메서드
- 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것
- 추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 함
- 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스도 추상클래스로 지정해야 함

# 11. 인터페이스
## 11.1 인터페이스란?
- 일종의 추상클래스
- 기본 설계도
- 추상화 정도가 높아서 오직 추상메서드와 상수만을 멤버로 가질 수 있음
- `interface`
- 인터페이스로부터만 상속받을 수 있으며, 다중상속 가능

## 11.4 인터페이스의 구현
- `implements`
- 구현하는 인터페이스의 메서드 중 일부만 구현한다면 추상클래스로 선언해야 함
- 상속과 구현 동시에 가능

## 11.6 인터페이스를 이용한 다형성
- 인터페이스도 클래스의 조상이라 할 수 있으므로, 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스 참조 가능
- 인터페이스 타입으로 형변환도 가능
- 인터페이스 타입의 매개변수는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 함
- 리턴타입이 인터페이스이면 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환해야 함

## 11.7 인터페이스의 장점
- 개발 시간 단축 가능
- 표준화 가능
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음
- 독립적인 프로그래밍 가능

# 12. 내부클래스
## 12.1 내부클래스란?
- 클래스 내에 선언된 클래스
- 두 클래스가 서로 긴밀한 관계에 있음
- 장점
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있음
    - 코드의 복잡성 감소(캡슐화)

## 12.2 내부클래스의 종류와 특징
